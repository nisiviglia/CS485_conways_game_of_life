/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package conwaygui;

import static conwaygui.ApplicationManager.mouseState;
import java.awt.Graphics;
import java.util.ArrayList;
import testing.MockData_View.View;
import static conwaygui.ApplicationManager.MouseState.POINTER;
import conwaygui.ApplicationManager.MoveDirection;
import static conwaygui.CoordGrouping.GroupType.SELECTION;

/**
 *
 * @author Steve Coluccio
 */
public class RenderPanel extends javax.swing.JPanel {

    //Temp delcaration
    private RenderRegion region;
    
    //mouse state info
    private boolean mouseDown = false;
    private Coordinate mouseDownCoordinate;
    
    //selection info
    private SelectionRegion currentSelection;
    
    public ArrayList<Coordinate> getLivingCells() {
        return region.getLivingCells();
    }
    
    public boolean isDirty(){
        return region.getView().isDirty();
    }
    
    /**
     * Creates new form RenderPanel
     */
    public RenderPanel() {
        initComponents();
        
        repaint();
        
        //current render info
        region = new RenderRegion();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        setBackground(new java.awt.Color(51, 51, 51));
        setForeground(new java.awt.Color(255, 255, 255));
        addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseDragged(java.awt.event.MouseEvent evt) {
                formMouseDragged(evt);
            }
            public void mouseMoved(java.awt.event.MouseEvent evt) {
                formMouseMoved(evt);
            }
        });
        addMouseListener(new java.awt.event.MouseAdapter() {
            public void mousePressed(java.awt.event.MouseEvent evt) {
                formMousePressed(evt);
            }
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                formMouseReleased(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 692, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 448, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

    
    
    //@MOUSE_RELEASE
    private void formMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseReleased
        
        Coordinate coord = region.getCoordFromMouse(evt.getX(), evt.getY());
        
        //Mouse state decisions
        switch(mouseState){
            case POINTER:
                
                if(mouseDownCoordinate.equals(coord)){
                    region.getView().flipCell(coord);
                }
                
                break;
            
            case SELECTION:
                if(currentSelection != null){
                    currentSelection.release(region.getView());
                }
                break;
            
            case PAN: 
                
                break;
        }
        
        mouseDown = false;
        mouseDownCoordinate = null;
        
        repaint();
    }//GEN-LAST:event_formMouseReleased

    //@MOUSE_MOVE
    //Only called when mouse is not pressed/dragging
    private void formMouseMoved(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseMoved
        Coordinate coord = region.getCoordFromMouse(evt.getX(), evt.getY());
        //this.setToolTipText(coord.toString());
        repaint();
        
        switch(ApplicationManager.mouseState){
            case POINTER:
                break;
              
            case SELECTION:
                break;
            
            case PAN:
                break;
        }
    }//GEN-LAST:event_formMouseMoved

    //@MOUSE_DOWN
    //Only called on initial press
    private void formMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMousePressed
        System.out.println("Mouse #: " + evt.getButton());
        mouseDown = true;
        Coordinate coord = region.getCoordFromMouse(evt.getX(), evt.getY());
        
        switch(ApplicationManager.mouseState){
            case POINTER:
                break;
              
            case SELECTION:
                switch(evt.getButton()){
                    case 1: //left mouse
                        //create a new selection region
                        currentSelection = new SelectionRegion(coord);
                        break;
                    case 3: //right mouse
                        //set current select to true/false (alive on first click)
                        if(currentSelection != null){
                            currentSelection.flip(region);
                        }
                        break;
                }
                break;
            case PAN:
                break;
        }
        
        mouseDownCoordinate = coord.copy();
        repaint();
    }//GEN-LAST:event_formMousePressed

    
    //@MOUSE_DRAG
    private void formMouseDragged(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseDragged
        Coordinate coord = region.getCoordFromMouse(evt.getX(), evt.getY());
        //this.setToolTipText(coord.toString());
        
        switch(ApplicationManager.mouseState){
            case POINTER:
                break;
            case SELECTION:
                if(mouseDown && currentSelection != null){
                    currentSelection.drag(coord);
                }
                break;
        }
        repaint();
    }//GEN-LAST:event_formMouseDragged


    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables


    
    /********************************************
        Main Render
    -Called whenever a system action takes place.
     * @param graphics
    */
    
    @Override
    public void paintComponent(Graphics graphics){
        super.paintComponent(graphics);
        
        int width = ApplicationManager.cellWidthCurrent;
        ArrayList<Coordinate> cellList = region.getLivingCells();
        
        //fill the living cell
        for(Coordinate coord : cellList){
            graphics.fillRect(
                    region.getAbsoluteX() + width * coord.x, 
                    region.getAbsoluteY() + width * coord.y, 
                    width, width);
        }
        
        //grid render
        for(int i = 0; i < region.getViewWidth(); i++){
            for(int j = 0; j < region.getViewHeight(); j++){
                graphics.drawRect(
                        region.getAbsoluteX() + width*j, 
                        region.getAbsoluteY() + width*i, 
                        width, width);
            }
        }
        
        //mouse feedback, highlights
        switch(ApplicationManager.mouseState){
            case POINTER:
                if(!mouseDown) { break; }
                graphics.setColor(ApplicationManager.COLOR_NORMAL_HIGHLIGHT);
                graphics.fillRect(
                        region.getAbsoluteX() + width*mouseDownCoordinate.x, 
                        region.getAbsoluteY() + width*mouseDownCoordinate.y, 
                        width, width);
                break;
            
            case SELECTION:
                //draw selection region
                if(currentSelection != null){
                    currentSelection.draw(graphics);
                }
                break;
        }
    }
    
    //Create clean grid
    public void newGrid(){
        region = new RenderRegion();
        currentSelection = null;
    }
    
    //Create new grid with current live cells piped from the current frame
    public void newGrid(ArrayList<Coordinate> frameCells){
        region = new RenderRegion(new View(frameCells));
        currentSelection = null;
    }
    
    //Adject current render region
    public void move(MoveDirection direction){
        region.move(direction);
        repaint();
    }
    

    /****************************************************************************
        RenderRegion
        
        This is the collection of data that is being rendered at this time. 
        Will hold a View that contains all living cells in that area. New RenderRegions
        * will be instantiated when requesting Regions from the execution team.
        
        NOTE: This is has a placeholder position for now. 
        NOTE: This is meant to be a wrapper around View (the raw data type) 
        * into something that has more flexibility to render how we choose, 
        * later down the road.
    
    ****************************************************************************/
    
    private class RenderRegion{
        
        private View view;
        private int absX; //coord
        private int absY; //coord
        
        public RenderRegion(View view){
            this.view = view;
            absX = -(view.width / 2);
            absY = -(view.width / 2);
        }
        
        //Default constructor
        public RenderRegion(){
            this(new View());
        }
        
        
        public View getView(){ return view; }
        
        /*
        @return: pixel value of x render coord
        */
        public int getAbsoluteX(){
            return absX * ApplicationManager.cellWidthCurrent;
        }
        
        /*
        @return: pixel value of y render coord
        */
        public int getAbsoluteY(){
            return absY * ApplicationManager.cellWidthCurrent;
        }
        
        //@return: List of current alive cells in this View
        public ArrayList<Coordinate> getLivingCells(){
            return view.livingCells;
        }
        
        public int getViewWidth(){
            return view.width;
        }
        
        public int getViewHeight(){
            return view.height;
        }
        
        //Convert raw mouse input into a Coordnate
        public Coordinate getCoordFromMouse(int mouse_x, int mouse_y){
            int rx = (Math.abs(getAbsoluteX()) + mouse_x) / ApplicationManager.cellWidthCurrent;
            int ry = (Math.abs(getAbsoluteY()) + mouse_y) / ApplicationManager.cellWidthCurrent;
            return new Coordinate(rx, ry);
        }
        
        public void move(MoveDirection direction){
            switch(direction){
                case UP:
                    absY += 1;
                    break;
                case DOWN:
                    absY -= 1;
                    break;
                case RIGHT:
                    absX -= 1;
                    break;
                case LEFT:
                    absX += 1;
                    break;
            }
            //check if need to grab new view
            System.out.println("RenderRegion move to : " + absX + "," + absY);
        }
    }
    
    
    
    /******************************
        SelectionRegion
    
        This is the data around the selection tool.
        * anchorCoord represents the initial cell clicked
        * drag coord is the current cell being dragged on
    
    */
    private class SelectionRegion{
        
        public Coordinate anchorCoord;
        public Coordinate dragCoord;
        
        //First right click on this region is alive, alternate after that
        private boolean initialFlip = true;
        
        public SelectionRegion(Coordinate anchor){
            this.anchorCoord = anchor;
            dragCoord = anchor; //need a copy of coord here
        }
        
        //Set new drag coordinate while mouse is being dragged
        public void drag(Coordinate dragCoord){
            this.dragCoord = dragCoord;
        }
        
        
        /***************************************************************
         * 
            Set current selection of coordinates
         *@TODO: Should these coords just be shipped off to ApplicationManager at this point
         * or juse have that info processed here??? 
         * 
         * @TODO: Maybe check if any living cells are in this selected region 
         * and create a list of those

         ***************************************************************/
         
        public void release(View view){
            System.out.println("Current Selection from : " 
                + anchorCoord.toString() 
                + " -> " 
                + dragCoord.toString());
            
            //get coords from RenderRegion between dragCoord and anchorCoord
            ArrayList<Coordinate> group = new ArrayList<Coordinate>();
            for(Coordinate c : view.livingCells){
                
                //@TODO : this whole boolean can definitely be cleaned up
                //        Probably can be made more readable
                boolean x_check = 
                        (anchorCoord.x > dragCoord.x && c.x >= dragCoord.x && c.x <= anchorCoord.x)
                        || (anchorCoord.x == dragCoord.x && anchorCoord.x == c.x)
                        || (c.x >= anchorCoord.x && c.x <= dragCoord.x);
                
                boolean y_check = 
                        (anchorCoord.y > dragCoord.y && c.y >= dragCoord.y && c.y <= anchorCoord.y)
                        || (anchorCoord.y == dragCoord.y && anchorCoord.y == c.y)
                        || (c.y >= anchorCoord.y && c.y <= dragCoord.y);
                
                if(x_check && y_check) {
                    group.add(c);
                    System.out.println("Selected Coord : " + c.toString());
                }
            }

            //create a new global grouping.
            //This grouping can now be manipulated with the other functions on GuiMain
            ApplicationManager.currentGroup = new CoordGrouping(SELECTION, group);
        }
        
        
        
        //Render call for this selection within the RenderPanel
        public void draw(Graphics graphics){
            graphics.setColor( 
                    mouseDown ? ApplicationManager.COLOR_SELECTION_DRAG
                    : ApplicationManager.COLOR_SELECTION_HIGHLIGHT);
            
            int width = ApplicationManager.cellWidthCurrent;
            int selection_x, selection_y, render_w, render_h;
            
            if(dragCoord.x - anchorCoord.x >= 0){
                selection_x = anchorCoord.x * width;
                render_w = width * (dragCoord.x - anchorCoord.x + 1);
            }else{
                selection_x = dragCoord.x * width;
                render_w = width * (anchorCoord.x - dragCoord.x + 1);
            }
            
            if(dragCoord.y - anchorCoord.y >= 0){
                selection_y = anchorCoord.y * width;
                render_h = width * (dragCoord.y - anchorCoord.y + 1);
            }else{
                selection_y = dragCoord.y * width;
                render_h = width * (anchorCoord.y - dragCoord.y + 1);
            }
            
            
            graphics.fillRect(
                    region.getAbsoluteX() + selection_x, 
                    region.getAbsoluteY() + selection_y, 
                    render_w, 
                    render_h);
        }
        
        
        //Flip Coordinates within this selection range
        public void flip(RenderRegion region){
            int dx = dragCoord.x - anchorCoord.x;
            int dy = dragCoord.y - anchorCoord.y;
            dx = dx >= 0 ? dx+1 : dx < 0 ? dx-1 : dx;
            dy = dy >= 0 ? dy+1 : dy < 0 ? dy-1 : dy;
            
            for(int i = anchorCoord.x; i !=  anchorCoord.x + dx; i += (dx/Math.abs(dx))){
                for(int j = anchorCoord.y; j != anchorCoord.y + dy; j += (dy/Math.abs(dy))){
                    region.getView().changeCell(new Coordinate(i,j), initialFlip);
                }
            }
            initialFlip = !initialFlip;
        }
    }
    

}
